# Praat utils
#
# This script is part of the utils CPrAN plugin for Praat.
# The latest version is available through CPrAN or at
# <http://cpran.net/plugins/utils>
#
# The utils plugin is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation, either
# version 3 of the License, or (at your option) any later version.
#
# The utils plugin is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with utils. If not, see <http://www.gnu.org/licenses/>.
#
# Copyright 2014, 2015 Jose Joaquin Atria

#! ~~~ params
#! in:
#!   .length: The length of the desired string
#! out:
#!   .return$: The generated pseudo-random string
#! ~~~
#!
#! A basic implementation of the pwgen(1) UNIX command, which generates
#! "pronounceable" random strings. These are made in this case by
#! alternating consonants and vowels (consonants come first).
#!
procedure pwgen (.length)
  .c = 0
  .return$ = ""
  for .i to .length
    .c = 1 - .c
    if .c
      @rndstr: 1, "c"
    else
      @rndstr: 1, "v"
    endif
    .return$ = .return$ + rndstr.return$
  endfor
endproc

#! ~~~ params
#! in:
#!   .length: The length of the desired string
#!   .charset$: The set of characters to use
#! out:
#!   .return$: The generated pseudo-random string
#! ~~~
#!
#! ~~~ praat synopsis
#! @rndstr: 10, "a: "            ; Lowercase alphabetic and a space
#! assert length(rndstr.return$) == 10
#! ~~~
#!
#! Generate a random string with `length` characters. The string in `charset$`
#! specifies what characters should be used to generate this string.
#!
#! Characters to the left of the leftmost colon (`:`) will each be parsed as
#! the shorthand for one of the eight predefined sets described below. If a
#! character appears more than once, the corresponding character set will be
#! included as many times as its shorthand appears. Characters without
#! corresponding character sets will be ignored.
#!
#! --------------------- ---------- ------------------------
#! Name                  Shorthand  Definition
#! --------------------- ---------- ------------------------
#! Lowercase vowels      `v`        `aeiou`
#! Lowercase consonants  `c`        `bcdfghjkmlnpqrstvwxyz`
#! Lowercase alphabetic  `a`        `v` + `c`
#! Uppercase vowels      `V`        `AEIOU`
#! Uppercase consonants  `C`        `BCDFGHJKMLNPQRSTVWXYZ`
#! Uppercase alphabetic  `A`        `V` + `C`
#! Numeric               `1`        `0123456789`
#! Symbols               `%`        `!?@#$%&+_`
#! --------------------- ---------- ------------------------
#!
#! Characters to the right of the colon (including any other colons) will be
#! included _as is_ to the final character set, This not only allows for
#! customisation of the set itself, but also to do fine-control of the
#! frequency of specific characters: if a given character should appear more
#! often, add it more times to the list.
#!
procedure rndstr (.length, .charset$)
  .charset$ = if .charset$ == "" then "a1" else .charset$ fi
  @split: ":", .charset$
  .sets$ = split.return$[1]
  .custom$ = if split.length > 1 then split.return$[2] else "" fi

  .consonants$ = "bcdfghjklmnpqrstvwxyz"
  .vowels$     = "aeiou"
  .digits$     = "0123456789"
  .symbols$    = "!?@#$%&+_"

  .sets = length(.sets$)
  .chars$ = .custom$
  for .i to .sets
    .c$ = mid$(.sets$, .i, 1)
    if    .c$ == "c"
      .chars$ = .chars$ + .consonants$
    elsif .c$ == "v"
      .chars$ = .chars$ + .vowels$
    elsif .c$ == "a"
      .chars$ = .chars$ + .vowels$ + .consonants$
    elsif .c$ == "C"
      @toUpper: .consonants$
      .chars$ = .chars$ + toUpper.return$
    elsif .c$ == "V"
      @toUpper: .vowels$
      .chars$ = .chars$ + toUpper.return$
    elsif .c$ == "A"
      @toUpper: .vowels$
      .chars$ = .chars$ + toUpper.return$
      @toUpper: .vowels$
      .chars$ = .chars$ + toUpper.return$
    elsif .c$ == "1"
      .chars$ = .chars$ + .digits$
    elsif .c$ == "%"
      .chars$ = .chars$ + .symbols$
    endif
  endfor

  .return$ = ""
  for .i to .length
    .return$ = .return$ + mid$(.chars$, randomInteger(1, length(.chars$)), 1)
  endfor
endproc

#!
#! ~~~ params
#! in:
#!   .separator$: The literal separator string
#!   .string$: The string to split
#! out:
#!   .return$[]: The split string fragments
#!   .length: The number of string fragments
#! ~~~
#!
#! ~~~ praat synopsis
#! @split: " ", "correct horse battery staple"
#! assert split.length == 4
#! for i to split.length
#!   appendInfoLine: split.return$[i]
#! endfor
#! # Prints
#! #   correct
#! #   horse
#! #   battery
#! #   staple
#! ~~~
#!
#! Takes the contents of `string$` and separates it into a number of smaller
#! strings using the string in `separator$` as the separator string. The
#! separator can be longer than one character. The match is made using it
#! as a string literal.
#!
#! The split substrings are stored in the `.return$[]` indexed variable,
#! which will have a length equal to the value in `.length`.
#!
procedure split (.sep$, .str$)
  .seplen = length(.sep$)
  .length = 0
  repeat
    .strlen = length(.str$)
    .sep = index(.str$, .sep$)
    if .sep > 0
      .part$ = left$(.str$, .sep-1)
      .str$ = mid$(.str$, .sep+.seplen, .strlen)
    else
      .part$ = .str$
    endif
    .length = .length+1
    .return$[.length] = .part$

    # For backwards compatibility only! Will disappear!
    .array$[.length] = .part$
  until .sep = 0
endproc

# Returns the number of occurences of a given character in a string (deprecated)
#
procedure numchar (.str$, .tgt$)
  appendInfoLine: "numchar is deprecated, use strcount instead"
  @strcount: .str$, .tgt$
  .return = strcount.return
endproc

# Returns the number of occurences of a given string in another string
#
procedure strcount (.str$, .tgt$)
  if .tgt$ != ""
    .pos = index(.str$, .tgt$)
    .tgtlen = length(.tgt$)
    .return = 0
    .substr$ = .str$
    while .pos
      .strlen = length(.substr$)
      .pos = index(.substr$, .tgt$)
      if .pos
        .return += 1
      endif
      .substr$ = right$(.str$, .strlen - (.pos + .tgtlen) + 1)
    endwhile
  else
    # Tme empty string can always be found, but it doesn't make
    # sense to count it
    .return = 1
  endif
endproc

# Returns the number of matches of a given regular expression pattern in a
# string
#
procedure strcount_regex (.str$, .ptn$)
  if .ptn$ != ""
    .pos = index_regex(.str$, .ptn$)
    .found$ = replace_regex$(.str$, ".*?(" + .ptn$ + ").*", "\1", 0)
    .return = 0
    .substr$ = .str$
    while .pos
      .string_length = length(.substr$)
      .pos = index_regex(.substr$, .ptn$)
      if .pos
        .return += 1
      endif
      .found$ = replace_regex$(.substr$, ".*?(" + .ptn$ + ").*", "\1", 0)
      .match_length = length(.found$)
      .substr$ = right$(.str$, .string_length - (.pos + .match_length) + 1)
    endwhile
  else
    # Tme empty string can always be found, but it doesn't make
    # sense to count it
    .return = 1
  endif
endproc

#! ~~~ params
#! in:
#!   .template$: The template string for name generation
#! out:
#!   .return$: The name of the created directory
#! ~~~
#!
#! ~~~ praat synopsis
#! @mktemp: "somefolder_XXXXXX"
#! assert fileReadable: mktemp.return$
#! ~~~
#!
#! Similar to the UNIX `mktemp(1)` command, this procedure creates a
#! directory with a name that is guaranteed to not exist at the time the
#! procedure was called. This procedure is not thread-safe, but is useful
#! for storing temporary files. The directory will not be automatically
#! deleted. The directory will be created in the default directory.
#!
#! The name of the directory is generated based on the contents of
#! `template$`, which needs to be of the form `baseXXXXX`, in which each
#! `X` character will be replaced with a random one using a single character
#! from the "a1" character set as defined in [@rndstr](#rndstr). The template
#! must have at least three random placeholders at the end.
#!
#! If no valid template is provided, no action will be taken and the returned
#! string will be `--undefined--`. If the template is the empty string,
#! `"tmp.XXXXXXXXXX"` will be used as a default.
#!
#! The name of the directory is stored in `.return$`, and the directory is
#! created automatically.
#!
procedure mktemp (.template$)
  if .template$ = ""
    .template$ = "tmp.XXXXXXXXXX"
  endif

  .number = index_regex(.template$, "X{3}$")
  .name$ = "--undefined--"
  if .number
    @normalDefaultDir()
    .number = index_regex(.template$, "X+$")
    .attempts = 0
    .base$ = left$(.template$, .number - 1)
    .random_length = length(.template$) - (.number - 1)

    repeat
      .attempts += 1
      @pwgen(.random_length)
      .name$ = defaultDirectory$ + .base$ + pwgen.return$
    until .attempts > 100 or !fileReadable(.name$)

    .name$ = if right$(.name$) != "/" then .name$ + "/" else .name$ fi
    .name$ = replace_regex$(.name$, "^~", homeDirectory$, 0)
    createDirectory: .name$
    @restoreDefaultDir()
  endif
  .return$ = .name$
endproc

#! ~~~ params
#! in:
#!   .template$: The template string for name generation
#! out:
#!   .return$: The name of the created file
#! ~~~
#!
#! ~~~ praat synopsis
#! @mktemp: "somefile_XXXXXX"
#! assert fileReadable: mktempfile.return$
#! ~~~
#!
#! Similar to [@mktemp](#mktemp), but this procedure creates temporary files.
#! The interface for both procedures is exactly the same.
#!
procedure mktempfile (.template$, .extension$)
  if left$(.extension$) == "."
    .extension$ = right$(.extension$, length(.extension$) - 1)
  endif
  if .template$ = ""
    .template$ = "tmp.XXXXXXXXXX"
  endif

  .number = index_regex(.template$, "X{3}$")
  .name$ = "--undefined--"
  if .number
    @normalDefaultDir()
    .number = index_regex(.template$, "X+$")
    .attempts = 0
    .base$ = left$(.template$, .number - 1)
    .random_length = length(.template$) - (.number - 1)

    repeat
      .attempts += 1
      @pwgen(.random_length)
      .name$ = defaultDirectory$ + .base$ + pwgen.return$
      if .extension$ != ""
        .name$ = .name$ + "." + .extension$
      endif
    until .attempts > 100 or !fileReadable(.name$)

    .random$ = pwgen.return$
    .name$ = replace_regex$(.name$, "^~", homeDirectory$, 0)
    writeFile: .name$, ""
    @restoreDefaultDir()
  endif
  .return$ = .name$
endproc

# Pad a number with zeroes to the left.
# Make sure that the .length is large enough to hold the padded string!
#
procedure zeropad (.n, .length)
  .n$ = string$(abs(.n))
  .sign$ = if .n < 0 then "-" else "" fi
  .pad$ = ""
  for .i to .length
    .pad$ = .pad$ + "0"
  endfor
  .return$ = .sign$ + right$(.pad$ + .n$, .length)
endproc

# Convert a string to lower-case
#
procedure toLower (.string$)
  .return$ = replace_regex$(.string$, "(.*)", "\L\1", 0)
endproc

# Convert a string to upper-case
#
procedure toUpper (.string$)
  .return$ = replace_regex$(.string$, "(.*)", "\U\1", 0)
endproc

# Check if the running version of Praat has access to GUI commands
# .return will be assigned to 1 if there are GUI commands, or 0
# otherwise.
#
procedure hasGUI ()
  .total = numberOfSelected()
  for .i to .total
    .original[.i] = selected(.i)
  endfor

  .obj = Create TextGrid: 0, 1, "test", ""
  .editor = nocheck View & Edit
  if .editor != undefined
    editor: .editor
      nocheck Close
    endeditor
    .return = 1
  else
    .return = 0
  endif

  nocheck Remove
  for .i to .total
    plusObject: .original[.i]
  endfor
endproc

# Normalise the preferences directory, so that it has a predictable
# name across platforms.
#
procedure normaliseDirectory: .dir$
  .return$ = replace_regex$(.dir$, "(con)?(\.(EXE|exe))?$", "", 0)
  .return$ = replace_regex$(.return$, "^~", homeDirectory$, 0)
  .return$ = replace_regex$(.return$, "\\", "/", 0)
  .return$ = .return$ + if right$(.return$) != "/" then "/" else "" fi
endproc

# Normalise a directory, so that it has a predictable
# name across platforms.
#
procedure normalPrefDir ()
  .old$ = preferencesDirectory$
  @normaliseDirectory: preferencesDirectory$
  preferencesDirectory$ = normaliseDirectory.return$
endproc

# Restore the original preferences directory, before normalisation.
# See normalPrefDir().
#
procedure restorePrefDir ()
  if variableExists("normalPrefDir.old$")
    preferencesDirectory$ = normalPrefDir.old$
  endif
endproc

# Normalise the default directory, so that it has a predictable
# name across platforms.
#
procedure normalDefaultDir ()
  .old$ = defaultDirectory$
  @normaliseDirectory: defaultDirectory$
  defaultDirectory$ = normaliseDirectory.return$
endproc

# Restore the original default directory, before normalisation.
# See normalDefaultDir().
#
procedure restoreDefaultDir ()
  if variableExists("normalDeaultDir.old$")
    defaultDirectory$ = normalDefaultDir.old$
  endif
endproc

# Normalise a string into a Praat name
#
procedure praatifyString: .string$
  .total = numberOfSelected()
  for .i to .total
    .original[.i] = selected(.i)
  endfor

  if .string$ != ""
    Create TextGrid: 0, 1, .string$, ""
    .return$ = selected$("TextGrid")
  else
    .return$ = .string$
  endif

  nocheck Remove
  for .i to .total
    plusObject: .original[.i]
  endfor
endproc
