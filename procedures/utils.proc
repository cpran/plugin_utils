# Praat utils
#
# This script is part of the utils CPrAN plugin for Praat.
# The latest version is available through CPrAN or at
# <http://cpran.net/plugins/utils>
#
# The utils plugin is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation, either
# version 3 of the License, or (at your option) any later version.
#
# The utils plugin is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with utils. If not, see <http://www.gnu.org/licenses/>.
#
# Copyright 2014, 2015 Jose Joaquin Atria

# Extremely limited version of pwgen(1). Currently, unlike the traditional
# command, this procedure does not strive for legibility, and acts simply as an
# alias for rndstr().
#
# In the future this will hopefully change.
#
procedure pwgen (.length)
  @rndstr(.length, "a1")
  .return$ = rndstr.return$
endproc

# Returns a random string of the specified length, with characters from the
# specified character sets.
#
procedure rndstr (.length, .charset$)
  .charset$ = if .charset$ = "" then "a1" else .charset$ fi
  .char$ = ""
  if index(.charset$, "a")
    .char$ = .char$ + "abcdefghijkmlnopqrstuvwxyz"
  endif
  if index(.charset$, "A")
    .char$ = .char$ + "ABCDEFGHIJKMLNOPQRSTUVWXYZ"
  endif
  if index(.charset$, "1")
    .char$ = .char$ + "0123456789"
  endif
  if index(.charset$, "%")
    .char$ = .char$ + "!?@#$%&+_"
  endif

  .return$ = ""
  for .i to .length
    .return$ = .return$ + mid$(.char$, randomInteger(1, length(.char$)), 1)
  endfor
endproc

# Split .str$ on .sep$ and store each found element in .array$ and
# length of .array$ in .length
#
# Usage:
#  include /path/to/this/script.praat
#  [code]
#  @split (SEPARATOR, STRING)
#  for i to split.length
#    str$[i] = split.return$[i]
#  endfor
#
# where SEPARATOR is a separator string and STRING is a string to
# separate.
#
# If string$ = "hello world", then after
# @split (" ", string$)
# split.return$[1] contains "hello" and split.return$[2] contains "world"
#
# Since .length stores the number of items separated by a string, it is always
# larger than the amount of occurences of that string by one, which means
# it can be used to count occurences as well.
#
procedure split (.sep$, .str$)
  .seplen = length(.sep$)
  .length = 0
  repeat
    .strlen = length(.str$)
    .sep = index(.str$, .sep$)
    if .sep > 0
      .part$ = left$(.str$, .sep-1)
      .str$ = mid$(.str$, .sep+.seplen, .strlen)
    else
      .part$ = .str$
    endif
    .length = .length+1
    .return$[.length] = .part$

    # For backwards compatibility only! Will disappear!
    .array$[.length] = .part$
  until .sep = 0
endproc

# Returns the number of occurences of a given character in a string
#
procedure numchar (.str$, .tgt$)
  .pos = index(.str$, .tgt$)
  .tgtlen = length(.tgt$)
  .return = 0
  .substr$ = .str$
  while .pos
    .strlen = length(.substr$)
    .pos = index(.substr$, .tgt$)
    if .pos
      .return += 1
    endif
    .substr$ = right$(.str$, .strlen - (.pos + .tgtlen) + 1)
  endwhile
endproc

# Create a temporary directory that is guaranteed not to exist
#
procedure mktemp (.template$)
  if .template$ = ""
    .template$ = "tmp.XXXXXXXXXX"
  endif

  .number = index_regex(.template$, "X{3}$")
  .name$ = "--undefined--"
  if .number
    .number = index_regex(.template$, "X+$")
    .attempts = 0
    .base$ = left$(.template$, .number - 1)
    .random_length = length(.template$) - (.number - 1)

    repeat
      .attempts += 1
      @pwgen(.random_length)
      .name$ = preferencesDirectory$ + "/" + .base$ + pwgen.return$
    until .attempts > 100 or !fileReadable(.name$)

    .name$ = if right$(.name$) != "/" then .name$ + "/" else .name$ fi
    .name$ = replace_regex$(.name$, "^~", homeDirectory$, 0)
    createDirectory: .name$
  else
    pauseScript: "Template must have at least three random placeholders at end."
  endif
  .return$ = .name$
endproc

# Pad a number with zeroes to the left.
# Make sure that the .length is large enough to hold the padded string!
#
procedure zeropad (.n, .length)
  .n$ = string$(abs(.n))
  .sign$ = if .n < 0 then "-" else "" fi
  .pad$ = ""
  for .i to .length
    .pad$ = .pad$ + "0"
  endfor
  .return$ = .sign$ + right$(.pad$ + .n$, .length)
endproc

# Convert a string to lower-case
#
procedure toLower (.string$)
  .return$ = replace_regex$(.string$, "(.*)", "\L\1", 0)
endproc

# Convert a string to upper-case
#
procedure toUpper (.string$)
  .return$ = replace_regex$(.string$, "(.*)", "\U\1", 0)
endproc

# Check if the running version of Praat has access to GUI commands
# .return will be assigned to 1 if there are GUI commands, or 0
# otherwise.
#
procedure hasGUI ()
  .total = numberOfSelected()
  for .i to .total
    .original[.i] = selected(.i)
  endfor

  .obj = Create TextGrid: 0, 1, "test", ""
  .editor = nocheck View & Edit
  if .editor != undefined
    editor: .editor
      nocheck Close
    endeditor
    .return = 1
  else
    .return = 0
  endif

  nocheck Remove
  for .i to .total
    plusObject: .original[.i]
  endfor
endproc

# Normalise the preferences directory, so that it has a predictable
# name across platforms.
#
procedure normalPrefDir ()
  .old$ = preferencesDirectory$
  preferencesDirectory$ = replace_regex$(preferencesDirectory$, "(con)?(\.(EXE|exe))?$", "", 0)
  preferencesDirectory$ = replace_regex$(preferencesDirectory$, "^~", homeDirectory$, 0)
  preferencesDirectory$ = replace_regex$(preferencesDirectory$, "\\", "/", 0)
  preferencesDirectory$ = preferencesDirectory$ +
    ... if right$(preferencesDirectory$) != "/" then "/" else "" fi
endproc

# Restore the original preferences directory, before normalisation.
# See normalPrefDir().
#
procedure restorePrefDir ()
  if variableExists("normalPrefDir.old$")
    preferencesDirectory$ = normalPrefDir.old$
  endif
endproc
